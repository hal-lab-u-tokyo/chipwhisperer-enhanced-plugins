# Target hardware implementation

[sample notebook](../notebooks/acquire_traces.ipynb) is available for acquiring traces from the target devices.

You can find a code snnipet for the target hardware implementation at the end of this document.

## [ESP32_AES128](../hardware/ESP32_AES128/)

PlatformIO project for AES-128 implementation on ESP32 is provided.
Please change macro in `main.cpp` as you like.
* CPU_FREQ: CPU frequency in MHz
* LED_PIN: GPIO pin number for LED
* TRIGGER_PIN: GPIO pin number for trigger signal

If encrpition key is set, the LED is turned on.

The trigger signal is asserted when the encryption starts and deasserted when the encryption ends.

To communicate with the ESP32, the UART-USB converter is required.


## SAKURA-X Shell
This is a our template of SAKURA-X board for easy evaluation of your cryptographic module.
For more information, please refer to its [repo](https://github.com/hal-lab-u-tokyo/sakura-x-shell).

This repository provides a driver template.

### [SakuraXShellBase](../lib/cw_plugins/targets/SakuraXShell.py)
This is an abstract class for Sakura-X Shell derived from `TargetTemplate` in Chipwhisperer.
If the following methods are implemented, the target can be used with `Chipwhisperer.capture_trace`.

* `getControl(self, **kwargs) -> SakuraXShellControlBase`
 return contoller object for target hardware on Sakura-X board (see below).
* `getExpected(self) -> bytes`: return the expected ciphertext.
* `loadEncryptionKey(self, key : bytes)`: set the encryption key.
* `loadInput(self, inputtext: bytes)`: load the plaintext.

### [SakuraXShellControlBase](../lib/cw_plugins/targets/SakuraXShell.py)
This is also an abstract class.
An instance of a derived class is an object to define the control of the target hardware on Sakura-X Shell, including key setting, sending plaintext, receiving ciphertext, and starting encryption.
The base class already defines communication methods with shell part of Sakura-X board.
Thus, the derived class at least needs to implement the following methods.

* constructor: `__init__(self, ser : serial.Serial, **kwargs)`
The constructor of the derived class requires at least one argument, `ser`, which is a serial object for communication with the shell part of Sakura-X board and call super constructor with `ser`.

* `send_key(self, key : bytes)`  
set the encryption key. This is called by `set_key` in `SakuraXShellBase`.
* `send_plaintext(self, plaintext : bytes)`  
send the plaintext to the target. This is called by `loadInput` in `SakuraXShellBase`.
* `run(self)`  
start the encryption. This is called by `go` in `SakuraXShellBase`, which is called by `Chipwhisperer.capture_trace`.
* `read_ciphertext(self, byte_len : int = 8) -> bytes`  
return the ciphertext. 

The following methods are defined in the base class `SakuraXShellControlBase` and can be used in the derived class.

* `write_data(self, addr : int, data : Iterable[Int])`  
write data to hardware deisgn on Kintex-7 FPGA via shell controller on Spartan-6 FPGA.  
Note that each element of `data` is treated as **32-bit** data.

* `read_data(self, addr : int, length : int) -> List[Int]`
read data from hardware design on Kintex-7 FPGA via shell controller on Spartan-6 FPGA.
Not that the length is the number of **32-bit** data (word size).

* `reset_command(self)`  
Send reset signal to modules on the Kintex-7 FPGA.

In addition to the above abstract methods, the derived class may need to implement `isDone(self) -> bool` method to ensure the encryption is completed.

### Examples
This repository provides example drivers for designs integrating AES-128 hardware cores in [sca_design_repo](https://github.com/hal-lab-u-tokyo/sca_design_repo) with the shell template.

Before using those, please configure the FPGAs on the board with the provided bitstreams or your built bitstreams.

1. RTL implementation of AES-128
To acquire traces from the RTL implementation, please use [`SakuraXShellExampleAES128BitRTL`](../lib/cw_plugins/targets/SakuraShellAESExamples.py) class.

The pin 1 of CN8 is used for the trigger signal, similar to SASEBO-GIII sample.

There are two versions of the RTL implementation, one is AIST implementation and the other is Google ProjectVault implementation.

To specify the implementation, please set `implmentation="aist"` or `implmentation="google"` keyword argument to the `con` method or `cw.target` routine.

The library loads a default hardware handoff file, which is generated by Vivado to parse address map of the hardware design.
If you want to use your own hardware handoff file, please set `hwh_file` keyword argument to the path of the hardware handoff file when calling `con` method or `cw.target` routine.


2. HLS implementation of AES-128
To acquire traces from the HLS implementation, please use [`SakuraXShellExampleAES128BitHLS`](../lib/cw_plugins/targets/SakuraShellAESExamples.py) class.

The pin 1 of CN8 is used for the trigger signal, similar to SASEBO-GIII sample.

It also loads a default hardware handoff file, which is generated by Vivado to parse address map of the hardware design.

## CW305-Shell
Similar to the SAKURA-X Shell, the CW305 Shell is a template for the CW305 board.
The original CW305 class and its data communication have some limitations.
A design based on our shell template and CW305Shell class provides ACK-based communication and more flexible data communication,
allowing vairable latency data response from the FPGA, data bus clock domain crossing, and so on.
For more information, please refer to its [repo](https://github.com/hal-lab-u-tokyo/cw305-shell).

This repository provides a driver template.

### [CW305ShellBase](../lib/cw_plugins/targets/CW305Shell.py)

Similar to `SakuraXShellBase`, this is an abstract class for CW305 Shell derived from `CW305` in Chipwhisperer.
A derived class needs to implement the following methods.

* `go(self)`: start the encryption.
* `getExpected(self) -> bytes`: return the expected ciphertext.
* `loadEncryptionKey(self, key: bytes)`: set the encryption key.
* `loadInput(self, inputtext: bytes)`: load the plaintext.
* `readOutput(self) -> bytes`: return the processed ciphertext.

In addition to the above abstract methods, the derived class may need to implement `isDone(self) -> bool` method to ensure the encryption is completed.

### Examples
Similar to the SAKURA-X Shell, this repository also provides example drivers for the same designs on the CW305 board.

1. RTL implementation of AES-128
The driver class is [`CW305ShellExampleAES128BitRTL`](../lib/cw_plugins/targets/CW305ShellAESExamples.py).

2. HLS implementation of AES-128
The driver class is [`CW305ShellExampleAES128BitHLS`](../lib/cw_plugins/targets/CW305ShellAESExamples.py).

## VexRiscv_SakuraX
VexRiscv is a 32-bit RISC-V CPU core and [VexRiscv_SakuraX](https://github.com/hal-lab-u-tokyo/VexRiscv_SakuraX) provides an implementation of VexRiscv on the Sakura-X board.

It is also designed based on the Sakura-X Shell, and [`SakuraXVexRISCVControlBase`](../lib//cw_plugins/targets/SakuraXVexRISCV.py) defines additional methods for controlling the CPU core, derived from `SakuraXShellControlBase`.
As described above, the derived class needs to implement the four methods `send_key`, `send_plaintext`, `run`, and `read_ciphertext`.

Its constructor requires the following arguments:
* ser (serial.Serial): serial object for communication with SAKURA-X board
* program (str): path to the elf binary file to be loaded to the CPU core

After instantiation, the CPU core boots with the program and starts running.

### Serial like communication with CPU core
The CPU core has a serial-like communication interface, which can be used for sending and receiving data.

The following methods are defined in `SakuraXVexRISCVControlBase` and can be used in the derived class.

* `send_bytes(self, data : bytes)`  
send byte data to the buffer that CPU core receives.

* `read_bytes(self, length : int) -> bytes`  
read byte data from the buffer that CPU core sends.

The following methods are available to check buffer status
* `is_send_buffer_full(self)`
* `is_send_buffer_empty(self)`
* `is_recv_buffer_full(self)`
* `is_recv_buffer_empty(self)`
* `get_send_buffer_bytes(self)`
* `get_recv_buffer_bytes(self)`

### AES example

This repository includes software implementations of AES-128 encryption for VexRiscv.
[`SakuraXVexRISCVAESExample`](../lib//cw_plugins/targets/SakuraXVexRISCVAESExample.py) is a derived class of `SakuraXShellBase`.
There are two implementations of AES-128 encryption in the repository, one is unmasked and the other is masked.
`SakuraXVexRISCVAESExample` uses the unmasked implementation as default.
To use the masked implementation, please set keyword argument `masked` to `True` for `con` method.

The pin 1 of CN8 is used for the trigger signal, similar to SASEBO-GIII sample.


## Code snippet for above examples without trace acquisition

```python
import chipwhisperer as cw
from cw_plugins.targets.ESP32 import ESP32 # <- ESP32 example
from cw_plugins.targets import SakuraXShellExampleAES128BitRTL # <- for SAKRA-X with RTL design example
from cw_plugins.targets import SakuraXShellExampleAES128BitHLS # <- for SAKRA-X with HLS design example
from cw_plugins.targets import CW305ShellExampleAES128BitRTL # <- for CW305 with RTL design example
from cw_plugins.targets import CW305ShellExampleAES128BitHLS # <- for CW305 with HLS design example
from cw_plugins.targets import SakuraXVexRISCVAESExample # <- for VexRiscv with software AES example

# instantiate the target hardware
target = SakuraXShellExampleAES128BitRTL()
scope = None # <- because oscilloscope is not used
hwh_file = "path/to/hwh_file"
target.con(scope, serial_port="/dev/ttyUSB0", hwh_file=hwh_file)

# key, plaintext generator in Chipwhisperer
ktp = cw.ktp.Basic()

# key loading
key = ktp.next_key()
print("key:", key)
target.loadEncryptionKey(key)

# plaintext loading
plaintext = ktp.next_text()
print("plaintext:", plaintext)
target.loadInput(plaintext)

# start encryption
target.go()

# wait for enough time or check the status of the target

# read ciphertext
ciphertext = cw.bytearray(target.readOutput())
print("ciphertext:", ciphertext)

expected = cw.bytearray(target.getExpected())
if ciphertext == expected:
	print("Success!")
else:
	print("Failed!")

```
